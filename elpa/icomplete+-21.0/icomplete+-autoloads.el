;;; icomplete+-autoloads.el --- automatically extracted autoloads
;;
;;; Code:


;;;### (autoloads nil "icomplete+" "icomplete+.el" (19886 51764))
;;; Generated autoloads from icomplete+.el

(when (< emacs-major-version 23) (defun icomplete-exhibit nil "Insert icomplete completions display.\nShould be run via minibuffer `post-command-hook'.\nSee `icomplete-mode' and `minibuffer-setup-hook'." (when (icomplete-simple-completing-p) (save-match-data (let* ((minibuf-begin (if (< emacs-major-version 21) (point-min) (minibuffer-prompt-end))) (contents (buffer-substring minibuf-begin (point-max))) (buffer-undo-list t)) (save-excursion (goto-char (point-max)) (unless (boundp 'icomplete-eoinput) (make-local-variable 'icomplete-eoinput)) (setq icomplete-eoinput (point)) (when (and (> (point-max) minibuf-begin) (save-excursion (goto-char minibuf-begin) (not (looking-at "\\(\\s-+$\\|\\s-*\\(\\s(\\|\\s\"\\|\\s'\\|\\s<\\|[0-9]\\)\\)"))) (or (> (point-max) icomplete-max-delay-chars) (if minibuffer-completion-table (cond ((numberp minibuffer-completion-table) (< minibuffer-completion-table icomplete-delay-completions-threshold)) ((sequencep minibuffer-completion-table) (< (length minibuffer-completion-table) icomplete-delay-completions-threshold)))) (sit-for icomplete-compute-delay))) (insert (icomplete-completions contents minibuffer-completion-table minibuffer-completion-predicate (not minibuffer-completion-confirm))))) (setq deactivate-mark nil))))))

(when (> emacs-major-version 22) (defun icomplete-exhibit nil "Insert icomplete completions display.\nShould be run via minibuffer `post-command-hook'.  See `icomplete-mode'\nand `minibuffer-setup-hook'." (when (and icomplete-mode (icomplete-simple-completing-p)) (save-match-data (save-excursion (goto-char (point-max)) (when (and (> (point-max) (minibuffer-prompt-end)) buffer-undo-list (save-excursion (goto-char (minibuffer-prompt-end)) (not (looking-at "\\(\\s-+$\\|\\s-*\\(\\s(\\|\\s\"\\|\\s'\\|\\s<\\|[0-9]\\)\\)"))) (or (> (- (point) (field-beginning)) icomplete-max-delay-chars) (and (sequencep minibuffer-completion-table) (< (length minibuffer-completion-table) icomplete-delay-completions-threshold)) (sit-for icomplete-compute-delay))) (let ((text (while-no-input (icomplete-completions (field-string) minibuffer-completion-table minibuffer-completion-predicate (not minibuffer-completion-confirm)))) (buffer-undo-list t) deactivate-mark) (when (stringp text) (move-overlay icomplete-overlay (point) (point) (current-buffer)) (put-text-property 0 1 'cursor t text) (overlay-put icomplete-overlay 'after-string text)))))))))

(when (< emacs-major-version 23) (defun icomplete-completions (name candidates predicate require-match) "Identify prospective candidates for minibuffer completion.\nNAME is the name to complete.\nCANDIDATES are the candidates to match.\nPREDICATE filters matches: they succeed only if this returns non-nil.\nREQUIRE-MATCH non-nil means the input must match a candidate.\n\nThe display is updated with each minibuffer keystroke during\nminibuffer completion.\n\nProspective completion suffixes (if any) are displayed, bracketed by\n\"()\", \"[]\", or \"{}\".  The choice of brackets is as follows:\n\n  (...) - A single prospect is identified and matching is enforced.\n  [...] - A single prospect is identified and matching is optional.\n  {...} - Multiple prospects are indicated, and further input is\n          needed to distinguish a single one.\n\nThe displays for unambiguous matches have \" [ Matched ]\" appended\n(whether complete or not), or \" [ No match ]\", if no eligible\nmatches exist.\nKeybindings for uniquely matched commands are displayed within the [].\n\nWhen more than one completion is available, the total number precedes\nthe suffixes display, like this:\n  M-x forw    14 (ard-) { char line list...}\n\nIf library `icicles.el' is also loaded, then you can cycle\ncompletions.  When you change cycling direction, the number of\nadditional cycle candidates, besides the current one, is displayed\nfollowing the rest of the icomplete info:\n  M-x forward-line   [Matched]  (13 more)." (when (and (listp candidates) (null (car candidates))) (setq candidates nil)) (let* ((comps (all-completions name candidates predicate)) (open-bracket-determined (if require-match "(" " [")) (close-bracket-determined (if require-match ") " "] ")) (keys nil) (nb-candidates (length comps)) nb-candidates-string) (if (null comps) (format (if (fboundp 'icicle-apropos-complete) "	%sNo prefix matches%s" "	%sNo matches%s") open-bracket-determined close-bracket-determined) (let* ((most-try (try-completion name (mapcar #'list comps))) (most (if (stringp most-try) most-try (car comps))) (most-len (length most)) (determ (and (> most-len (length name)) (concat open-bracket-determined (substring most (length name)) close-bracket-determined))) (open-bracket-prospects "{ ") (close-bracket-prospects " }") (prospects-len 0) prompt prompt-rest prospects most-is-exact comp) (when determ (put-text-property 0 (length determ) 'face 'icompletep-determined determ)) (if (eq most-try t) (setq prospects nil) (while (and comps (< prospects-len icompletep-prospects-length)) (setq comp (substring (car comps) most-len) comps (cdr comps)) (cond ((string-equal comp "") (setq most-is-exact t)) ((member comp prospects)) (t (setq prospects (cons comp prospects) prospects-len (+ (length comp) 1 prospects-len)))))) (setq prompt-rest (if prospects (concat open-bracket-prospects (and most-is-exact ", ") (mapconcat 'identity (sort prospects #'string-lessp) "  ") (and comps "...") close-bracket-prospects) (concat "	[ Matched" (if (setq keys (and icomplete-show-key-bindings (commandp (intern-soft most)) (icomplete-get-keys most))) (concat "; " keys) (setq keys nil)) " ]"))) (put-text-property 0 (length prompt-rest) 'face 'icompletep-choices prompt-rest) (cond ((< nb-candidates 2) (setq prompt (concat "      " determ prompt-rest)) (when (eq last-command this-command) (setq icicle-nb-of-other-cycle-candidates 0))) (t (setq nb-candidates-string (format "%7d " nb-candidates)) (put-text-property (string-match "\\S-" nb-candidates-string) (1- (length nb-candidates-string)) 'face 'icompletep-nb-candidates nb-candidates-string) (setq prompt (concat nb-candidates-string determ prompt-rest)))) (when keys (put-text-property (+ 18 (length determ)) (1- (length prompt)) 'face 'icompletep-keys prompt)) (when (and (boundp 'icicle-last-completion-candidate) (> icicle-nb-of-other-cycle-candidates 0) (= 1 nb-candidates) icicle-last-completion-candidate (not (eq last-command this-command))) (setq nb-candidates-string (format "  (%d more)" icicle-nb-of-other-cycle-candidates)) (put-text-property (string-match "\\S-" nb-candidates-string) (length nb-candidates-string) 'face 'icompletep-nb-candidates nb-candidates-string) (setq prompt (concat prompt nb-candidates-string))) prompt)))))

(when (> emacs-major-version 22) (defun icomplete-completions (name candidates predicate require-match) "Identify prospective candidates for minibuffer completion.\nNAME is the name to complete.\nCANDIDATES are the candidates to match.\nPREDICATE filters matches: they succeed only if it returns non-nil.\nREQUIRE-MATCH non-nil means the input must match a candidate.\n\nThe display is updated with each minibuffer keystroke during\nminibuffer completion.\n\nProspective completion suffixes (if any) are displayed, bracketed by\n\"()\", \"[]\", or \"{}\".  The choice of brackets is as follows:\n\n  (...) - A single prospect is identified, and matching is enforced.\n  [...] - A single prospect is identified, and matching is optional.\n  {...} - Multiple prospects are indicated, and further input is\n          needed to distinguish a single one.\n\nThe displays for unambiguous matches have ` [ Matched ]' appended\n(whether complete or not), or ` [ No matches ]', if no eligible\nmatches exist.  (Keybindings for uniquely matched commands are\nexhibited within the square brackets, [].)\n\nWhen more than one completion is available, the total number precedes\nthe suffixes display, like this:\n  M-x forw    14 (ard-) { char line list...}\n\nIf library `icicles.el' is also loaded, then you can cycle\ncompletions.  When you change cycling direction, the number of\nadditional cycle candidates, besides the current one, is displayed\nfollowing the rest of the icomplete info:\n  M-x forward-line   [Matched]  (13 more)." (when (and (listp candidates) (null (car candidates))) (setq candidates nil)) (let* ((comps (all-completions name candidates predicate)) (nb-candidates (length comps)) (open-bracket (if require-match "(" " [")) (close-bracket (if require-match ") " "] "))) (if (not (consp comps)) (format (if (fboundp 'icicle-apropos-complete) "	%sNo prefix matches%s" "	%sNo matches%s") open-bracket close-bracket) (let* ((most-try (completion-try-completion name comps nil (length name))) (most (if (consp most-try) (car most-try) (if most-try (car comps) ""))) (compare (compare-strings name nil nil most nil nil completion-ignore-case)) (determ (and (not (or (eq t compare) (eq t most-try) (= (setq compare (1- (abs compare))) (length most)))) (concat open-bracket (cond ((= compare (length name)) (substring most compare)) ((< compare 5) most) (t (concat "..." (substring most compare)))) close-bracket))) (prospects-len (+ (string-width (buffer-string)) 8 (length determ) 2 -2 5)) (prospects-max (* (+ icomplete-prospects-height (/ prospects-len (window-width))) (window-width))) (prefix-len (if (eq t (compare-strings (car comps) nil (length most) most nil nil completion-ignore-case)) (length most) (let ((comps-prefix (try-completion "" comps))) (and (stringp comps-prefix) (length comps-prefix))))) (keys nil) prompt nb-candidates-string prompt-rest prospects most-is-exact comp limit) (when determ (put-text-property 0 (length determ) 'face 'icompletep-determined determ)) (if (eq most-try t) (setq prospects nil) (while (and comps (not limit)) (setq comp (if prefix-len (substring (car comps) prefix-len) (car comps)) comps (cdr comps)) (cond ((string-equal comp "") (setq most-is-exact t)) ((member comp prospects)) (t (setq prospects-len (+ (string-width comp) 2 prospects-len)) (if (< prospects-len prospects-max) (push comp prospects) (setq limit t)))))) (setq prompt-rest (if prospects (concat "{ " (and most-is-exact ", ") (mapconcat 'identity (sort prospects #'string-lessp) "  ") (and limit "...") " }") (concat "	[ Matched" (if (setq keys (and icomplete-show-key-bindings (commandp (intern-soft most)) (icomplete-get-keys most))) (concat "; " keys) (setq keys nil)) " ]"))) (put-text-property 0 (length prompt-rest) 'face 'icompletep-choices prompt-rest) (cond ((< nb-candidates 2) (setq prompt (concat "      " determ prompt-rest)) (when (eq last-command this-command) (setq icicle-nb-of-other-cycle-candidates 0))) (t (setq nb-candidates-string (format "%7d " nb-candidates)) (put-text-property (string-match "\\S-" nb-candidates-string) (1- (length nb-candidates-string)) 'face 'icompletep-nb-candidates nb-candidates-string) (setq prompt (concat nb-candidates-string determ prompt-rest)))) (when keys (put-text-property (+ 18 (length determ)) (1- (length prompt)) 'face 'icompletep-keys prompt)) (when (and (boundp 'icicle-last-completion-candidate) (> icicle-nb-of-other-cycle-candidates 0) (= 1 nb-candidates) icicle-last-completion-candidate (not (eq last-command this-command))) (setq nb-candidates-string (format "  (%d more)" icicle-nb-of-other-cycle-candidates)) (put-text-property (string-match "\\S-" nb-candidates-string) (length nb-candidates-string) 'face 'icompletep-nb-candidates nb-candidates-string) (setq prompt (concat prompt nb-candidates-string))) prompt)))))

;;;***

;;;### (autoloads nil nil ("icomplete+-pkg.el") (19886 51764 655079))

;;;***

(provide 'icomplete+-autoloads)
;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; coding: utf-8
;; End:
;;; icomplete+-autoloads.el ends here
